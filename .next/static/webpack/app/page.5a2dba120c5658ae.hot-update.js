"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/api/meals/route.ts":
/*!********************************!*\
  !*** ./app/api/meals/route.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELETE: () => (/* binding */ DELETE),\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   createMeal: () => (/* binding */ createMeal),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(app-pages-browser)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var mysql2_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mysql2/promise */ \"(app-pages-browser)/../node_modules/mysql2/promise.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// IMPORTANT: This file must be in /app/api/meals/route.ts\n// Make sure this is a server-side API route, not a client component\n\n\n// Dynamic import to ensure mysql2 is only loaded on the server\nconst getMysqlConnection = async ()=>{\n    const mysql = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! mysql2/promise */ \"(app-pages-browser)/../node_modules/mysql2/promise.js\", 19));\n    return mysql.default;\n};\n// Database configuration\nconst dbConfig_old = {\n    host: process.env.DB_HOST || 'localhost',\n    user: process.env.DB_USER || 'root',\n    password: process.env.DB_PASSWORD || '',\n    database: process.env.DB_NAME || 'calorie-compass',\n    port: parseInt(process.env.DB_PORT || '3306'),\n    waitForConnections: true,\n    connectionLimit: 10,\n    queueLimit: 0\n};\nconst dbConfig = {\n    host: process.env.DB_HOST || 'localhost',\n    user: process.env.DB_USER || 'root',\n    password: process.env.DB_PASSWORD || '',\n    database: process.env.DB_NAME || 'auth_app',\n    waitForConnections: true,\n    connectionLimit: 10,\n    queueLimit: 0\n};\n// Create connection pool\nconst pool = mysql2_promise__WEBPACK_IMPORTED_MODULE_1__.createPool(dbConfig);\n// GET - Get user's meals\nasync function GET(request) {\n    let connection;\n    try {\n        console.log('üìò API: Getting meals...');\n        // Dynamic import of mysql2\n        const mysql = await getMysqlConnection();\n        connection = await mysql.createConnection(dbConfig);\n        console.log('üìò API: Connected to database');\n        const [rows] = await connection.execute('SELECT * FROM user_meals ORDER BY created_at DESC');\n        console.log('üìò API: Query executed, rows found:', rows.length);\n        // Close connection before returning\n        await connection.end();\n        console.log('üìò API: Connection closed');\n        // Return consistent structure that frontend expects\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            meals: rows || [],\n            count: rows.length\n        });\n    } catch (error) {\n        console.error('‚ùå API Error:', error.message);\n        // Make sure connection is closed on error\n        if (connection) {\n            try {\n                await connection.end();\n            } catch (closeError) {\n                console.error('‚ùå Error closing connection:', closeError);\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message || 'Database connection failed',\n            meals: [] // Always return meals array even on error\n        }, {\n            status: 500\n        });\n    }\n}\n// POST - Create a new meal\n// export async function createMeal(request: any) {\nasync function createMeal(request) {\n    let connection;\n    try {\n        const body = await request.json();\n        console.log('üìò API: Creating new meal:', body);\n        // const [response] = await pool.execute(\n        //   \"INSERT INTO user_meals (meal_name, meal_type) VALUES (?, ?)\",\n        //   [\n        //     request.meal_name || 'Unnamed Meal',\n        //     request.meal_type || 'breakfast'\n        //   ]\n        // ) as any;\n        /////// OLD STUFF BELOW //////\n        const mysql = await getMysqlConnection();\n        connection = await mysql.createConnection(dbConfig);\n        const [result] = await connection.execute('INSERT INTO user_meals (meal_name, meal_type, total_calories, total_protein, total_carbs, total_fat) VALUES (?, ?, ?, ?, ?, ?)', [\n            request.meal_name || 'Unnamed Meal',\n            request.meal_type || 'breakfast',\n            request.total_calories || 0,\n            request.total_protein || 0,\n            request.total_carbs || 0,\n            request.total_fat || 0\n        ]);\n        // await connection.end();\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: 'Meal created successfully',\n            mealId: result.insertId\n        });\n    } catch (error) {\n        console.error('‚ùå API Error:', error.message);\n        if (connection) {\n            try {\n                await connection.end();\n            } catch (closeError) {\n                console.error('‚ùå Error closing connection:', closeError);\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message || 'Failed to create meal'\n        }, {\n            status: 500\n        });\n    }\n}\n// DELETE - Delete a meal\nasync function DELETE(request) {\n    let connection;\n    try {\n        const { searchParams } = new URL(request.url);\n        const id = searchParams.get('id');\n        if (!id) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: 'Meal ID is required'\n            }, {\n                status: 400\n            });\n        }\n        const mysql = await getMysqlConnection();\n        connection = await mysql.createConnection(dbConfig);\n        const [result] = await connection.execute('DELETE FROM user_meals WHERE id = ?', [\n            id\n        ]);\n        await connection.end();\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: 'Meal deleted successfully',\n            affectedRows: result.affectedRows\n        });\n    } catch (error) {\n        console.error('‚ùå API Error:', error.message);\n        if (connection) {\n            try {\n                await connection.end();\n            } catch (closeError) {\n                console.error('‚ùå Error closing connection:', closeError);\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message || 'Failed to delete meal'\n        }, {\n            status: 500\n        });\n    }\n}\n// This ensures the route runs only on the server\nconst runtime = 'nodejs';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9hcGkvbWVhbHMvcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDBEQUEwRDtBQUMxRCxvRUFBb0U7QUFFWjtBQUVyQjtBQUVuQywrREFBK0Q7QUFDL0QsTUFBTUUscUJBQXFCO0lBQ3pCLE1BQU1ELFFBQVEsTUFBTSx5S0FBd0I7SUFDNUMsT0FBT0EsTUFBTUUsT0FBTztBQUN0QjtBQUVBLHlCQUF5QjtBQUN6QixNQUFNQyxlQUFlO0lBQ25CQyxNQUFNQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLE9BQU8sSUFBSTtJQUM3QkMsTUFBTUgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxPQUFPLElBQUk7SUFDN0JDLFVBQVVMLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0ssV0FBVyxJQUFJO0lBQ3JDQyxVQUFVUCxPQUFPQSxDQUFDQyxHQUFHLENBQUNPLE9BQU8sSUFBSTtJQUNqQ0MsTUFBTUMsU0FBU1YsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDVSxPQUFPLElBQUk7SUFDdENDLG9CQUFvQjtJQUNwQkMsaUJBQWlCO0lBQ2pCQyxZQUFZO0FBQ2Q7QUFFQSxNQUFNQyxXQUFXO0lBQ2ZoQixNQUFNQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLE9BQU8sSUFBSTtJQUM3QkMsTUFBTUgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxPQUFPLElBQUk7SUFDN0JDLFVBQVVMLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0ssV0FBVyxJQUFJO0lBQ3JDQyxVQUFVUCxPQUFPQSxDQUFDQyxHQUFHLENBQUNPLE9BQU8sSUFBSTtJQUNqQ0ksb0JBQW9CO0lBQ3BCQyxpQkFBaUI7SUFDakJDLFlBQVk7QUFDZDtBQUVBLHlCQUF5QjtBQUN6QixNQUFNRSxPQUFPckIsc0RBQWdCLENBQUNvQjtBQUU5Qix5QkFBeUI7QUFDbEIsZUFBZUcsSUFBSUMsT0FBb0I7SUFDNUMsSUFBSUM7SUFFSixJQUFJO1FBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztRQUVa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QkFDdkJDLFNBQVM7Z0JBQ1RHLE9BQU87WUFDVCxHQUFHO2dCQUNERyxRQUFRO1lBQ1Y7UUFDRjtRQUVBLE1BQU14QyxRQUFRLE1BQU1DO1FBQ3BCd0IsYUFBYSxNQUFNekIsTUFBTTRCLGdCQUFnQixDQUFDUjtRQUUxQyxNQUFNLENBQUN1QixPQUFPLEdBQUcsTUFBTWxCLFdBQVdLLE9BQU8sQ0FDdkMsdUNBQ0E7WUFBQzBCO1NBQUc7UUFHTixNQUFNL0IsV0FBV08sR0FBRztRQUVwQixPQUFPakMscURBQVlBLENBQUNrQyxJQUFJLENBQUM7WUFDdkJDLFNBQVM7WUFDVEksU0FBUztZQUNUb0IsY0FBYyxPQUFnQkEsWUFBWTtRQUM1QztJQUVGLEVBQUUsT0FBT3JCLE9BQVk7UUFDbkJYLFFBQVFXLEtBQUssQ0FBQyxnQkFBZ0JBLE1BQU1DLE9BQU87UUFFM0MsSUFBSWIsWUFBWTtZQUNkLElBQUk7Z0JBQ0YsTUFBTUEsV0FBV08sR0FBRztZQUN0QixFQUFFLE9BQU9PLFlBQVk7Z0JBQ25CYixRQUFRVyxLQUFLLENBQUMsK0JBQStCRTtZQUMvQztRQUNGO1FBRUEsT0FBT3hDLHFEQUFZQSxDQUFDa0MsSUFBSSxDQUFDO1lBQ3ZCQyxTQUFTO1lBQ1RHLE9BQU9BLE1BQU1DLE9BQU8sSUFBSTtRQUMxQixHQUFHO1lBQ0RFLFFBQVE7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxpREFBaUQ7QUFDMUMsTUFBTW1CLFVBQVUsU0FBUyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxwcmluY2Ugc3VubnlcXGNhbG9yaWUtY29tcGFzc1xcYXBwXFxhcGlcXG1lYWxzXFxyb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJTVBPUlRBTlQ6IFRoaXMgZmlsZSBtdXN0IGJlIGluIC9hcHAvYXBpL21lYWxzL3JvdXRlLnRzXHJcbi8vIE1ha2Ugc3VyZSB0aGlzIGlzIGEgc2VydmVyLXNpZGUgQVBJIHJvdXRlLCBub3QgYSBjbGllbnQgY29tcG9uZW50XHJcblxyXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xyXG5cclxuaW1wb3J0IG15c3FsIGZyb20gJ215c3FsMi9wcm9taXNlJztcclxuXHJcbi8vIER5bmFtaWMgaW1wb3J0IHRvIGVuc3VyZSBteXNxbDIgaXMgb25seSBsb2FkZWQgb24gdGhlIHNlcnZlclxyXG5jb25zdCBnZXRNeXNxbENvbm5lY3Rpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgbXlzcWwgPSBhd2FpdCBpbXBvcnQoJ215c3FsMi9wcm9taXNlJyk7XHJcbiAgcmV0dXJuIG15c3FsLmRlZmF1bHQ7XHJcbn07XHJcblxyXG4vLyBEYXRhYmFzZSBjb25maWd1cmF0aW9uXHJcbmNvbnN0IGRiQ29uZmlnX29sZCA9IHtcclxuICBob3N0OiBwcm9jZXNzLmVudi5EQl9IT1NUIHx8ICdsb2NhbGhvc3QnLFxyXG4gIHVzZXI6IHByb2Nlc3MuZW52LkRCX1VTRVIgfHwgJ3Jvb3QnLFxyXG4gIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5EQl9QQVNTV09SRCB8fCAnJyxcclxuICBkYXRhYmFzZTogcHJvY2Vzcy5lbnYuREJfTkFNRSB8fCAnY2Fsb3JpZS1jb21wYXNzJyxcclxuICBwb3J0OiBwYXJzZUludChwcm9jZXNzLmVudi5EQl9QT1JUIHx8ICczMzA2JyksXHJcbiAgd2FpdEZvckNvbm5lY3Rpb25zOiB0cnVlLFxyXG4gIGNvbm5lY3Rpb25MaW1pdDogMTAsXHJcbiAgcXVldWVMaW1pdDogMFxyXG59O1xyXG5cclxuY29uc3QgZGJDb25maWcgPSB7XHJcbiAgaG9zdDogcHJvY2Vzcy5lbnYuREJfSE9TVCB8fCAnbG9jYWxob3N0JyxcclxuICB1c2VyOiBwcm9jZXNzLmVudi5EQl9VU0VSIHx8ICdyb290JyxcclxuICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuREJfUEFTU1dPUkQgfHwgJycsXHJcbiAgZGF0YWJhc2U6IHByb2Nlc3MuZW52LkRCX05BTUUgfHwgJ2F1dGhfYXBwJyxcclxuICB3YWl0Rm9yQ29ubmVjdGlvbnM6IHRydWUsXHJcbiAgY29ubmVjdGlvbkxpbWl0OiAxMCxcclxuICBxdWV1ZUxpbWl0OiAwLFxyXG59O1xyXG5cclxuLy8gQ3JlYXRlIGNvbm5lY3Rpb24gcG9vbFxyXG5jb25zdCBwb29sID0gbXlzcWwuY3JlYXRlUG9vbChkYkNvbmZpZyk7XHJcblxyXG4vLyBHRVQgLSBHZXQgdXNlcidzIG1lYWxzXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICBsZXQgY29ubmVjdGlvbjtcclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk5ggQVBJOiBHZXR0aW5nIG1lYWxzLi4uJyk7XHJcbiAgICBcclxuICAgIC8vIER5bmFtaWMgaW1wb3J0IG9mIG15c3FsMlxyXG4gICAgY29uc3QgbXlzcWwgPSBhd2FpdCBnZXRNeXNxbENvbm5lY3Rpb24oKTtcclxuICAgIGNvbm5lY3Rpb24gPSBhd2FpdCBteXNxbC5jcmVhdGVDb25uZWN0aW9uKGRiQ29uZmlnKTtcclxuICAgIGNvbnNvbGUubG9nKCfwn5OYIEFQSTogQ29ubmVjdGVkIHRvIGRhdGFiYXNlJyk7XHJcbiAgICBcclxuICAgIGNvbnN0IFtyb3dzXSA9IGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZShcclxuICAgICAgJ1NFTEVDVCAqIEZST00gdXNlcl9tZWFscyBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0MnXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+TmCBBUEk6IFF1ZXJ5IGV4ZWN1dGVkLCByb3dzIGZvdW5kOicsIChyb3dzIGFzIGFueVtdKS5sZW5ndGgpO1xyXG4gICAgXHJcbiAgICAvLyBDbG9zZSBjb25uZWN0aW9uIGJlZm9yZSByZXR1cm5pbmdcclxuICAgIGF3YWl0IGNvbm5lY3Rpb24uZW5kKCk7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TmCBBUEk6IENvbm5lY3Rpb24gY2xvc2VkJyk7XHJcbiAgICBcclxuICAgIC8vIFJldHVybiBjb25zaXN0ZW50IHN0cnVjdHVyZSB0aGF0IGZyb250ZW5kIGV4cGVjdHNcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lYWxzOiByb3dzIHx8IFtdLFxyXG4gICAgICBjb3VudDogKHJvd3MgYXMgYW55W10pLmxlbmd0aFxyXG4gICAgfSk7XHJcbiAgICBcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgQVBJIEVycm9yOicsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgXHJcbiAgICAvLyBNYWtlIHN1cmUgY29ubmVjdGlvbiBpcyBjbG9zZWQgb24gZXJyb3JcclxuICAgIGlmIChjb25uZWN0aW9uKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5lbmQoKTtcclxuICAgICAgfSBjYXRjaCAoY2xvc2VFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjbG9zaW5nIGNvbm5lY3Rpb246JywgY2xvc2VFcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcsXHJcbiAgICAgIG1lYWxzOiBbXSAvLyBBbHdheXMgcmV0dXJuIG1lYWxzIGFycmF5IGV2ZW4gb24gZXJyb3JcclxuICAgIH0sIHtcclxuICAgICAgc3RhdHVzOiA1MDBcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUE9TVCAtIENyZWF0ZSBhIG5ldyBtZWFsXHJcbi8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVNZWFsKHJlcXVlc3Q6IGFueSkge1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTWVhbChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gIGxldCBjb25uZWN0aW9uO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TmCBBUEk6IENyZWF0aW5nIG5ldyBtZWFsOicsIGJvZHkpO1xyXG4gICAgXHJcblxyXG4gICAgLy8gY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IHBvb2wuZXhlY3V0ZShcclxuICAgIC8vICAgXCJJTlNFUlQgSU5UTyB1c2VyX21lYWxzIChtZWFsX25hbWUsIG1lYWxfdHlwZSkgVkFMVUVTICg/LCA/KVwiLFxyXG4gICAgLy8gICBbXHJcbiAgICAvLyAgICAgcmVxdWVzdC5tZWFsX25hbWUgfHwgJ1VubmFtZWQgTWVhbCcsXHJcbiAgICAvLyAgICAgcmVxdWVzdC5tZWFsX3R5cGUgfHwgJ2JyZWFrZmFzdCdcclxuICAgIC8vICAgXVxyXG4gICAgLy8gKSBhcyBhbnk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8vLy8vLyBPTEQgU1RVRkYgQkVMT1cgLy8vLy8vXHJcblxyXG4gICAgY29uc3QgbXlzcWwgPSBhd2FpdCBnZXRNeXNxbENvbm5lY3Rpb24oKTtcclxuICAgIGNvbm5lY3Rpb24gPSBhd2FpdCBteXNxbC5jcmVhdGVDb25uZWN0aW9uKGRiQ29uZmlnKTtcclxuICAgIFxyXG4gICAgY29uc3QgW3Jlc3VsdF0gPSBhd2FpdCBjb25uZWN0aW9uLmV4ZWN1dGUoXHJcbiAgICAgICdJTlNFUlQgSU5UTyB1c2VyX21lYWxzIChtZWFsX25hbWUsIG1lYWxfdHlwZSwgdG90YWxfY2Fsb3JpZXMsIHRvdGFsX3Byb3RlaW4sIHRvdGFsX2NhcmJzLCB0b3RhbF9mYXQpIFZBTFVFUyAoPywgPywgPywgPywgPywgPyknLFxyXG4gICAgICBbXHJcbiAgICAgICAgcmVxdWVzdC5tZWFsX25hbWUgfHwgJ1VubmFtZWQgTWVhbCcsXHJcbiAgICAgICAgcmVxdWVzdC5tZWFsX3R5cGUgfHwgJ2JyZWFrZmFzdCcsXHJcbiAgICAgICAgcmVxdWVzdC50b3RhbF9jYWxvcmllcyB8fCAwLFxyXG4gICAgICAgIHJlcXVlc3QudG90YWxfcHJvdGVpbiB8fCAwLFxyXG4gICAgICAgIHJlcXVlc3QudG90YWxfY2FyYnMgfHwgMCxcclxuICAgICAgICByZXF1ZXN0LnRvdGFsX2ZhdCB8fCAwXHJcbiAgICAgICAgLy8gYm9keS5tZWFsX25hbWUgfHwgJ1VubmFtZWQgTWVhbCcsXHJcbiAgICAgICAgLy8gYm9keS5tZWFsX3R5cGUgfHwgJ2JyZWFrZmFzdCcsXHJcbiAgICAgICAgLy8gYm9keS50b3RhbF9jYWxvcmllcyB8fCAwLFxyXG4gICAgICAgIC8vIGJvZHkudG90YWxfcHJvdGVpbiB8fCAwLFxyXG4gICAgICAgIC8vIGJvZHkudG90YWxfY2FyYnMgfHwgMCxcclxuICAgICAgICAvLyBib2R5LnRvdGFsX2ZhdCB8fCAwXHJcbiAgICAgIF1cclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIGF3YWl0IGNvbm5lY3Rpb24uZW5kKCk7XHJcbiAgICBcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6ICdNZWFsIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5JyxcclxuICAgICAgbWVhbElkOiAocmVzdWx0IGFzIGFueSkuaW5zZXJ0SWRcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBFcnJvcjonLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIFxyXG4gICAgaWYgKGNvbm5lY3Rpb24pIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBjb25uZWN0aW9uLmVuZCgpO1xyXG4gICAgICB9IGNhdGNoIChjbG9zZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNsb3NpbmcgY29ubmVjdGlvbjonLCBjbG9zZUVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgbWVhbCdcclxuICAgIH0sIHtcclxuICAgICAgc3RhdHVzOiA1MDBcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gREVMRVRFIC0gRGVsZXRlIGEgbWVhbFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gREVMRVRFKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XHJcbiAgbGV0IGNvbm5lY3Rpb247XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcclxuICAgIGNvbnN0IGlkID0gc2VhcmNoUGFyYW1zLmdldCgnaWQnKTtcclxuICAgIFxyXG4gICAgaWYgKCFpZCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiAnTWVhbCBJRCBpcyByZXF1aXJlZCdcclxuICAgICAgfSwge1xyXG4gICAgICAgIHN0YXR1czogNDAwXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBteXNxbCA9IGF3YWl0IGdldE15c3FsQ29ubmVjdGlvbigpO1xyXG4gICAgY29ubmVjdGlvbiA9IGF3YWl0IG15c3FsLmNyZWF0ZUNvbm5lY3Rpb24oZGJDb25maWcpO1xyXG4gICAgXHJcbiAgICBjb25zdCBbcmVzdWx0XSA9IGF3YWl0IGNvbm5lY3Rpb24uZXhlY3V0ZShcclxuICAgICAgJ0RFTEVURSBGUk9NIHVzZXJfbWVhbHMgV0hFUkUgaWQgPSA/JyxcclxuICAgICAgW2lkXVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgYXdhaXQgY29ubmVjdGlvbi5lbmQoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ01lYWwgZGVsZXRlZCBzdWNjZXNzZnVsbHknLFxyXG4gICAgICBhZmZlY3RlZFJvd3M6IChyZXN1bHQgYXMgYW55KS5hZmZlY3RlZFJvd3NcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBFcnJvcjonLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIFxyXG4gICAgaWYgKGNvbm5lY3Rpb24pIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBjb25uZWN0aW9uLmVuZCgpO1xyXG4gICAgICB9IGNhdGNoIChjbG9zZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNsb3NpbmcgY29ubmVjdGlvbjonLCBjbG9zZUVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWxldGUgbWVhbCdcclxuICAgIH0sIHtcclxuICAgICAgc3RhdHVzOiA1MDBcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVGhpcyBlbnN1cmVzIHRoZSByb3V0ZSBydW5zIG9ubHkgb24gdGhlIHNlcnZlclxyXG5leHBvcnQgY29uc3QgcnVudGltZSA9ICdub2RlanMnOyJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJteXNxbCIsImdldE15c3FsQ29ubmVjdGlvbiIsImRlZmF1bHQiLCJkYkNvbmZpZ19vbGQiLCJob3N0IiwicHJvY2VzcyIsImVudiIsIkRCX0hPU1QiLCJ1c2VyIiwiREJfVVNFUiIsInBhc3N3b3JkIiwiREJfUEFTU1dPUkQiLCJkYXRhYmFzZSIsIkRCX05BTUUiLCJwb3J0IiwicGFyc2VJbnQiLCJEQl9QT1JUIiwid2FpdEZvckNvbm5lY3Rpb25zIiwiY29ubmVjdGlvbkxpbWl0IiwicXVldWVMaW1pdCIsImRiQ29uZmlnIiwicG9vbCIsImNyZWF0ZVBvb2wiLCJHRVQiLCJyZXF1ZXN0IiwiY29ubmVjdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJjcmVhdGVDb25uZWN0aW9uIiwicm93cyIsImV4ZWN1dGUiLCJsZW5ndGgiLCJlbmQiLCJqc29uIiwic3VjY2VzcyIsIm1lYWxzIiwiY291bnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJjbG9zZUVycm9yIiwic3RhdHVzIiwiY3JlYXRlTWVhbCIsImJvZHkiLCJyZXN1bHQiLCJtZWFsX25hbWUiLCJtZWFsX3R5cGUiLCJ0b3RhbF9jYWxvcmllcyIsInRvdGFsX3Byb3RlaW4iLCJ0b3RhbF9jYXJicyIsInRvdGFsX2ZhdCIsIm1lYWxJZCIsImluc2VydElkIiwiREVMRVRFIiwic2VhcmNoUGFyYW1zIiwiVVJMIiwidXJsIiwiaWQiLCJnZXQiLCJhZmZlY3RlZFJvd3MiLCJydW50aW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/api/meals/route.ts\n"));

/***/ })

});